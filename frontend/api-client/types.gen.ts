// This file is auto-generated by @hey-api/openapi-ts

/**
 * ApiKeyResponse
 * Response model for API key operations
 */
export type ApiKeyResponse = {
  /**
   * Success
   */
  success: boolean;
  /**
   * Message
   */
  message?: string | null;
  /**
   * Error
   */
  error?: string | null;
  /**
   * Error Type
   */
  error_type?: string | null;
  provider: ModelProvider;
  /**
   * Key Name
   */
  key_name?: string | null;
  /**
   * Created At
   */
  created_at?: Date | null;
};

/**
 * AvailableModelsResponse
 * Response model for available models
 */
export type AvailableModelsResponse = {
  /**
   * Providers
   */
  providers: {
    [key: string]: Array<string>;
  };
  /**
   * Current Limits
   */
  current_limits: {
    [key: string]: number;
  };
  /**
   * User Has Keys
   */
  user_has_keys: Array<string>;
};

/**
 * Body_delete_user_api_key_backend_enhanced
 */
export type BodyDeleteUserApiKeyBackendEnhanced = {
  /**
   * Token
   * JWT authentication token
   */
  token: string;
  /**
   * Provider
   * Provider name to delete key for
   */
  provider: string;
  /**
   * Key Id
   * Specific key ID to delete
   */
  key_id?: string | null;
};

/**
 * Body_generate_graph_route_api_repo_generate_graph_post
 */
export type BodyGenerateGraphRouteApiRepoGenerateGraphPost = {
  /**
   * Repo Url
   * URL to a downloadable ZIP of the repository.
   */
  repo_url?: string | null;
  /**
   * Branch
   * Branch for GitHub repo URL. If not specified, uses the repository's default branch.
   */
  branch?: string | null;
  /**
   * Zip File
   * A ZIP file of the repository.
   */
  zip_file?: (Blob | File) | null;
  /**
   * Access Token
   * Optional GitHub token for accessing private repositories.
   */
  access_token?: string | null;
};

/**
 * Body_generate_structure_route_api_repo_generate_structure_post
 */
export type BodyGenerateStructureRouteApiRepoGenerateStructurePost = {
  /**
   * Repo Url
   * URL to a downloadable ZIP of the repository.
   */
  repo_url?: string | null;
  /**
   * Branch
   * Branch for GitHub repo URL. If not specified, uses the repository's default branch.
   */
  branch?: string | null;
  /**
   * Zip File
   * A ZIP file of the repository.
   */
  zip_file?: (Blob | File) | null;
  /**
   * Access Token
   * Optional GitHub token for accessing private repositories.
   */
  access_token?: string | null;
};

/**
 * Body_generate_subgraph_route_api_repo_generate_subgraph_post
 */
export type BodyGenerateSubgraphRouteApiRepoGenerateSubgraphPost = {
  /**
   * Repo Url
   * URL to a downloadable ZIP of the repository.
   */
  repo_url?: string | null;
  /**
   * Branch
   * Branch for GitHub repo URL.
   */
  branch?: string | null;
  /**
   * Access Token
   * Optional GitHub token.
   */
  access_token?: string | null;
  /**
   * Center Node Id
   * Center node id for ego network.
   */
  center_node_id?: string | null;
  /**
   * Depth
   * Traversal depth for ego network.
   */
  depth?: number | null;
  /**
   * Categories
   * Comma-separated categories filter.
   */
  categories?: string | null;
  /**
   * Directories
   * Comma-separated directory prefixes filter.
   */
  directories?: string | null;
  /**
   * Relationship Types
   * Comma-separated relationship types filter.
   */
  relationship_types?: string | null;
  /**
   * Min Degree
   * Minimum degree for nodes.
   */
  min_degree?: number | null;
  /**
   * Limit
   * Max nodes in subgraph.
   */
  limit?: number | null;
};

/**
 * Body_generate_text_route_api_repo_generate_text_post
 */
export type BodyGenerateTextRouteApiRepoGenerateTextPost = {
  /**
   * Repo Url
   * URL to a downloadable ZIP of the repository (e.g., GitHub archive link).
   */
  repo_url?: string | null;
  /**
   * Branch
   * Branch to use if repo_url is a GitHub repository link. If not specified, uses the repository's default branch.
   */
  branch?: string | null;
  /**
   * Zip File
   * A ZIP file of the repository.
   */
  zip_file?: (Blob | File) | null;
  /**
   * Access Token
   * Optional GitHub token for accessing private repositories.
   */
  access_token?: string | null;
};

/**
 * Body_generate_wiki_api_documentation_generate_wiki_post
 */
export type BodyGenerateWikiApiDocumentationGenerateWikiPost = {
  /**
   * Repository Url
   * URL of the repository to generate documentation for
   */
  repository_url: string;
  /**
   * Language
   * Language for the documentation
   */
  language?: string | null;
  /**
   * Comprehensive
   * Whether to generate comprehensive documentation
   */
  comprehensive?: boolean | null;
  /**
   * Provider Name
   * Provider name for the documentation generation (openai, anthropic, gemini)
   */
  provider_name?: string | null;
  /**
   * Model Name
   * Specific model name to use for generation
   */
  model_name?: string | null;
  /**
   * Temperature
   * Temperature for AI generation (0.0-1.5)
   */
  temperature?: number | null;
};

/**
 * Body_get_available_models_backend_enhanced
 */
export type BodyGetAvailableModelsBackendEnhanced = {
  /**
   * Provider
   * Specific provider to get models for
   */
  provider?: string | null;
};

/**
 * Body_get_indexed_repositories_api_indexed_repos__post
 */
export type BodyGetIndexedRepositoriesApiIndexedReposPost = {
  /**
   * Limit
   * Maximum number of repositories to return
   */
  limit?: number;
  /**
   * Offset
   * Number of repositories to skip
   */
  offset?: number;
};

/**
 * Body_get_user_api_keys_backend_enhanced
 */
export type BodyGetUserApiKeysBackendEnhanced = {
  /**
   * Token
   * JWT authentication token
   */
  token: string;
};

/**
 * Body_get_wiki_status_api_documentation_wiki_status_post
 */
export type BodyGetWikiStatusApiDocumentationWikiStatusPost = {
  /**
   * Repo Id
   * ID of the repository to check wiki generation status for
   */
  repo_id: string;
};

/**
 * Body_is_wiki_generated_api_documentation_is_wiki_generated_post
 */
export type BodyIsWikiGeneratedApiDocumentationIsWikiGeneratedPost = {
  /**
   * Repo Id
   * ID of the repository to check wiki generation status for
   */
  repo_id: string;
};

/**
 * Body_list_repository_docs_api_documentation_repository_docs_post
 */
export type BodyListRepositoryDocsApiDocumentationRepositoryDocsPost = {
  /**
   * Repo Id
   * ID of the repository to list documentation files for
   */
  repo_id: string;
};

/**
 * Body_list_user_chat_sessions_api_backend_chat_sessions_post
 */
export type BodyListUserChatSessionsApiBackendChatSessionsPost = {
  /**
   * Repository Identifier
   * Repository identifier in format owner/repo/branch
   */
  repository_identifier: string;
};

/**
 * Body_process_chat_message_api_backend_chat_chat_post
 */
export type BodyProcessChatMessageApiBackendChatChatPost = {
  /**
   * Message
   * User's message/question
   */
  message: string;
  /**
   * Repository Id
   * Repository ID to chat about
   */
  repository_id: string;
  /**
   * Use User
   * Whether to use the user's saved API key
   */
  use_user?: boolean;
  /**
   * Chat Id
   * Chat session ID (auto-generated if not provided)
   */
  chat_id?: string | null;
  /**
   * Conversation Id
   * Conversation thread ID (auto-generated if not provided)
   */
  conversation_id?: string | null;
  /**
   * Provider
   * LLM provider (openai, anthropic, gemini, groq)
   */
  provider?: string;
  /**
   * Model
   * Model name
   */
  model?: string;
  /**
   * Temperature
   * Response randomness (0.0-2.0)
   */
  temperature?: number;
  /**
   * Max Tokens
   * Maximum tokens for context (1-1000000)
   */
  max_tokens?: number | null;
  /**
   * Include Full Context
   * Include full repository content as context
   */
  include_full_context?: boolean;
  /**
   * Context Search Query
   * Specific search query for context retrieval
   */
  context_search_query?: string | null;
};

/**
 * Body_save_api_key_backend_enhanced
 */
export type BodySaveApiKeyBackendEnhanced = {
  /**
   * Token
   * JWT authentication token
   */
  token: string;
  /**
   * Provider
   * Provider name (openai, anthropic, gemini, groq)
   */
  provider: string;
  /**
   * Api Key
   * API key to save
   */
  api_key: string;
  /**
   * Key Name
   * Optional friendly name for the key
   */
  key_name?: string | null;
  /**
   * Verify Key
   * Whether to verify key before saving
   */
  verify_key?: boolean;
};

/**
 * Body_save_user_api_key_api_backend_chat_keys_save_post
 */
export type BodySaveUserApiKeyApiBackendChatKeysSavePost = {
  /**
   * Provider
   * Provider name (openai, anthropic, gemini, groq)
   */
  provider: string;
  /**
   * Api Key
   * API key
   */
  api_key: string;
  /**
   * Key Name
   * Friendly name for the key
   */
  key_name?: string | null;
  /**
   * Verify Key
   * Whether to verify the key before saving
   */
  verify_key?: boolean;
};

/**
 * Body_search_context_api_backend_chat_context_search_post
 */
export type BodySearchContextApiBackendChatContextSearchPost = {
  /**
   * Repository Id
   * Repository ID to search
   */
  repository_id: string;
  /**
   * Query
   * Search query
   */
  query: string;
  /**
   * Max Results
   * Maximum number of results (1-20)
   */
  max_results?: number;
};

/**
 * Body_stream_chat_response_api_backend_chat_chat_stream_post
 */
export type BodyStreamChatResponseApiBackendChatChatStreamPost = {
  /**
   * Message
   * User's message/question
   */
  message: string;
  /**
   * Repository Id
   * Repository ID to chat about
   */
  repository_id: string;
  /**
   * Use User
   * Whether to use the user's saved API key
   */
  use_user?: boolean;
  /**
   * Chat Id
   * Chat session ID (auto-generated if not provided)
   */
  chat_id?: string | null;
  /**
   * Conversation Id
   * Conversation thread ID (auto-generated if not provided)
   */
  conversation_id?: string | null;
  /**
   * Provider
   * LLM provider (openai, anthropic, gemini, groq)
   */
  provider?: string;
  /**
   * Model
   * Model name
   */
  model?: string;
  /**
   * Temperature
   * Response randomness (0.0-2.0)
   */
  temperature?: number;
  /**
   * Max Tokens
   * Maximum tokens for context (1-1000000)
   */
  max_tokens?: number | null;
  /**
   * Context Mode
   * Context mode: full, smart, or agentic
   */
  context_mode?: string;
  /**
   * Repository Branch
   * Repository branch for more precise matching
   */
  repository_branch?: string | null;
};

/**
 * Body_update_chat_settings_api_backend_chat_settings_post
 */
export type BodyUpdateChatSettingsApiBackendChatSettingsPost = {
  /**
   * Chat Id
   * Chat session ID to update
   */
  chat_id: string;
  /**
   * Title
   * New chat title
   */
  title?: string | null;
  /**
   * Default Provider
   * Default LLM provider
   */
  default_provider?: string | null;
  /**
   * Default Model
   * Default model name
   */
  default_model?: string | null;
  /**
   * Default Temperature
   * Default temperature (0.0-2.0)
   */
  default_temperature?: number | null;
};

/**
 * Body_verify_api_key_backend_enhanced
 */
export type BodyVerifyApiKeyBackendEnhanced = {
  /**
   * Token
   * JWT authentication token
   */
  token: string;
  /**
   * Provider
   * Provider name (openai, anthropic, gemini, groq)
   */
  provider: string;
  /**
   * Api Key
   * API key to verify
   */
  api_key: string;
};

/**
 * Body_verify_user_api_key_api_backend_chat_keys_verify_post
 */
export type BodyVerifyUserApiKeyApiBackendChatKeysVerifyPost = {
  /**
   * Provider
   * Provider name (openai, anthropic, gemini, groq)
   */
  provider: string;
  /**
   * Api Key
   * API key to verify
   */
  api_key: string;
};

/**
 * ChatResponse
 * Response model for non-streaming chat interactions
 */
export type ChatResponse = {
  /**
   * Success
   */
  success: boolean;
  /**
   * Message
   */
  message?: string | null;
  /**
   * Error
   */
  error?: string | null;
  /**
   * Error Type
   */
  error_type?: string | null;
  /**
   * Chat Id
   */
  chat_id: string;
  /**
   * Conversation Id
   */
  conversation_id: string;
  /**
   * Ai Response
   */
  ai_response?: string | null;
  /**
   * Context Used
   */
  context_used?: string | null;
  /**
   * Context Metadata
   * Smart context selection metadata
   */
  context_metadata?: {
    [key: string]: unknown;
  } | null;
  usage?: TokenUsage | null;
  /**
   * Model Used
   */
  model_used?: string | null;
  /**
   * Provider
   */
  provider?: string | null;
  /**
   * Response Time
   * Response time in seconds
   */
  response_time?: number | null;
  daily_usage?: DailyUsage | null;
};

/**
 * ChatSessionListItem
 * Basic chat session info for listing
 */
export type ChatSessionListItem = {
  /**
   * Chat Id
   */
  chat_id: string;
  /**
   * Conversation Id
   */
  conversation_id: string;
  /**
   * Title
   */
  title: string;
};

/**
 * ChatSessionListResponse
 * Response for listing chat sessions
 */
export type ChatSessionListResponse = {
  /**
   * Success
   */
  success: boolean;
  /**
   * Sessions
   */
  sessions: Array<ChatSessionListItem>;
};

/**
 * ChatSessionResponse
 * Response model for chat session information
 */
export type ChatSessionResponse = {
  /**
   * Chat Id
   */
  chat_id: string;
  /**
   * Title
   */
  title?: string | null;
  /**
   * Repository Name
   */
  repository_name: string;
  /**
   * Repository Id
   */
  repository_id: string;
  /**
   * Created At
   */
  created_at: Date;
  /**
   * Updated At
   */
  updated_at: Date;
  /**
   * Is Active
   */
  is_active?: boolean;
  default_model_provider?: ModelProvider;
  /**
   * Default Model Name
   */
  default_model_name?: string;
  /**
   * Default Temperature
   */
  default_temperature?: number;
  /**
   * Use Own Key
   */
  use_own_key?: boolean;
  /**
   * Daily Requests Count
   */
  daily_requests_count?: number;
  /**
   * Daily Limit
   */
  daily_limit?: number;
  /**
   * Recent Conversations
   */
  recent_conversations?: Array<ConversationHistoryResponse>;
};

/**
 * ChatSettingsResponse
 * Response model for chat settings
 */
export type ChatSettingsResponse = {
  /**
   * Success
   */
  success: boolean;
  /**
   * Message
   */
  message?: string | null;
  /**
   * Error
   */
  error?: string | null;
  /**
   * Error Type
   */
  error_type?: string | null;
  /**
   * Settings
   */
  settings?: {
    [key: string]: unknown;
  } | null;
};

/**
 * ContextSearchResponse
 * Response model for context search
 */
export type ContextSearchResponse = {
  /**
   * Success
   */
  success: boolean;
  /**
   * Message
   */
  message?: string | null;
  /**
   * Error
   */
  error?: string | null;
  /**
   * Error Type
   */
  error_type?: string | null;
  /**
   * Results
   */
  results?: Array<ContextSearchResult>;
  /**
   * Total Found
   */
  total_found?: number;
  /**
   * Query Used
   */
  query_used: string;
};

/**
 * ContextSearchResult
 * Individual search result
 */
export type ContextSearchResult = {
  /**
   * Line Number
   */
  line_number: number;
  /**
   * Content
   */
  content: string;
  /**
   * Context
   */
  context: string;
};

/**
 * ConversationHistoryResponse
 * Response model for conversation history
 */
export type ConversationHistoryResponse = {
  /**
   * Chat Id
   */
  chat_id: string;
  /**
   * Conversation Id
   */
  conversation_id: string;
  /**
   * Title
   */
  title?: string | null;
  /**
   * Messages
   */
  messages: Array<MessageResponse>;
  /**
   * Created At
   */
  created_at: Date;
  /**
   * Updated At
   */
  updated_at: Date;
  /**
   * Total Tokens Used
   */
  total_tokens_used?: number;
  model_provider: ModelProvider;
  /**
   * Model Name
   */
  model_name: string;
};

/**
 * DailyUsage
 * Daily usage tracking
 */
export type DailyUsage = {
  /**
   * Requests Used
   */
  requests_used: number;
  /**
   * Requests Limit
   */
  requests_limit: number;
  /**
   * Reset Date
   */
  reset_date: string;
};

/**
 * DocumentationFile
 */
export type DocumentationFile = {
  metadata: FileMetadata;
  /**
   * Content
   */
  content: string;
  /**
   * Preview
   */
  preview: string;
  /**
   * Word Count
   */
  word_count: number;
  /**
   * Read Time
   */
  read_time: number;
};

/**
 * ErrorResponse
 */
export type ErrorResponse = {
  /**
   * Detail
   */
  detail: string;
};

/**
 * FileData
 */
export type FileData = {
  /**
   * Path
   */
  path: string;
  /**
   * Content
   */
  content: string;
};

/**
 * FileMetadata
 */
export type FileMetadata = {
  /**
   * Filename
   */
  filename: string;
  /**
   * Size
   */
  size: number;
  /**
   * Modified
   */
  modified: string;
  /**
   * Type
   */
  type: string;
};

/**
 * GitHubAccount
 * GitHub account information
 */
export type GitHubAccount = {
  /**
   * Login
   */
  login: string;
  /**
   * Id
   */
  id: number;
  /**
   * Avatar Url
   */
  avatar_url: string;
  /**
   * Type
   */
  type?: string | null;
};

/**
 * GitHubInstallation
 * GitHub App installation
 */
export type GitHubInstallation = {
  /**
   * Id
   */
  id: number;
  account: GitHubAccount;
  /**
   * App Id
   */
  app_id: number;
  /**
   * Target Type
   */
  target_type: string;
  /**
   * Target Id
   */
  target_id?: number | null;
  /**
   * Created At
   */
  created_at?: string | null;
  /**
   * Updated At
   */
  updated_at?: string | null;
};

/**
 * GitHubInstallationsResponse
 * Response for GitHub installations endpoint
 */
export type GitHubInstallationsResponse = {
  /**
   * Installations
   */
  installations: Array<GitHubInstallation>;
  /**
   * User Id
   */
  user_id: number;
  /**
   * User Login
   */
  user_login: string;
};

/**
 * GitHubRepositoriesResponse
 * Response for GitHub repositories endpoint
 */
export type GitHubRepositoriesResponse = {
  /**
   * Repositories
   */
  repositories: Array<GitHubRepository>;
  /**
   * Total Count
   */
  total_count: number;
};

/**
 * GitHubRepository
 * GitHub repository information
 */
export type GitHubRepository = {
  /**
   * Id
   */
  id: number;
  /**
   * Name
   */
  name: string;
  /**
   * Full Name
   */
  full_name: string;
  /**
   * Description
   */
  description?: string | null;
  /**
   * Private
   */
  private: boolean;
  /**
   * Html Url
   */
  html_url: string;
  /**
   * Language
   */
  language?: string | null;
  /**
   * Stargazers Count
   */
  stargazers_count?: number;
  /**
   * Forks Count
   */
  forks_count?: number;
  /**
   * Default Branch
   */
  default_branch?: string;
  /**
   * Updated At
   */
  updated_at?: string | null;
};

/**
 * GraphEdge
 */
export type GraphEdge = {
  /**
   * Source
   */
  source: string;
  /**
   * Target
   */
  target: string;
  /**
   * Relationship
   */
  relationship: string;
};

/**
 * GraphNode
 */
export type GraphNode = {
  /**
   * Id
   */
  id: string;
  /**
   * Name
   */
  name: string;
  /**
   * Category
   */
  category: string;
  /**
   * File
   */
  file?: string | null;
  /**
   * Start Line
   */
  start_line?: number | null;
  /**
   * End Line
   */
  end_line?: number | null;
  /**
   * Code
   */
  code?: string | null;
};

/**
 * GraphResponse
 */
export type GraphResponse = {
  /**
   * Html Url
   */
  html_url?: string | null;
  /**
   * Nodes
   */
  nodes: Array<GraphNode>;
  /**
   * Edges
   */
  edges: Array<GraphEdge>;
};

/**
 * HTTPValidationError
 */
export type HttpValidationError = {
  /**
   * Detail
   */
  detail?: Array<ValidationError>;
};

/**
 * IndexedRepositoriesResponse
 */
export type IndexedRepositoriesResponse = {
  /**
   * Repositories
   */
  repositories: Array<IndexedRepository>;
  /**
   * Total Count
   */
  total_count: number;
  /**
   * User Tier
   */
  user_tier: string;
};

/**
 * IndexedRepository
 */
export type IndexedRepository = {
  /**
   * Repo Id
   */
  repo_id: string;
  /**
   * Repo Name
   */
  repo_name: string;
  /**
   * Branch
   */
  branch: string;
  /**
   * Source
   */
  source: string;
  /**
   * Github Url
   */
  github_url?: string | null;
  /**
   * Commit Sha
   */
  commit_sha?: string | null;
  /**
   * Created At
   */
  created_at: Date;
  /**
   * Updated At
   */
  updated_at: Date;
  /**
   * File Size Mb
   */
  file_size_mb?: number | null;
};

/**
 * IsWikiGeneratedResponse
 */
export type IsWikiGeneratedResponse = {
  /**
   * Is Generated
   */
  is_generated: boolean;
  /**
   * Status
   */
  status: string;
  /**
   * Message
   */
  message?: string;
  /**
   * Error
   */
  error?: string | null;
};

/**
 * LoginRequest
 */
export type LoginRequest = {
  /**
   * Access Token
   */
  access_token: string;
};

/**
 * LoginResponse
 */
export type LoginResponse = {
  /**
   * Jwt Token
   */
  jwt_token: string;
  /**
   * Expires In
   */
  expires_in: number;
  /**
   * User Id
   */
  user_id: string;
  /**
   * Token Type
   */
  token_type?: string;
  /**
   * Refresh Token
   */
  refresh_token?: string | null;
  /**
   * Refresh Expires In
   */
  refresh_expires_in?: number | null;
};

/**
 * MessageResponse
 * Response model for individual messages
 */
export type MessageResponse = {
  /**
   * Role
   */
  role: 'user' | 'assistant' | 'system';
  /**
   * Content
   */
  content: string;
  /**
   * Timestamp
   */
  timestamp: Date;
  /**
   * Context Used
   */
  context_used?: string | null;
  /**
   * Metadata
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
};

/**
 * ModelProvider
 * Supported LLM providers
 */
export type ModelProvider = 'openai' | 'anthropic' | 'gemini' | 'groq';

/**
 * ModelProvider
 * Supported LLM providers
 */
export const ModelProvider = {
  OPENAI: 'openai',
  ANTHROPIC: 'anthropic',
  GEMINI: 'gemini',
  GROQ: 'groq',
} as const;

/**
 * NavigationData
 */
export type NavigationData = {
  /**
   * Sidebar
   */
  sidebar: Array<SidebarItem>;
  /**
   * Total Pages
   */
  total_pages: number;
};

/**
 * RefreshTokenRequest
 */
export type RefreshTokenRequest = {
  /**
   * Refresh Token
   */
  refresh_token: string;
};

/**
 * RefreshTokenResponse
 */
export type RefreshTokenResponse = {
  /**
   * Access Token
   */
  access_token: string;
  /**
   * Expires In
   */
  expires_in: number;
  /**
   * Token Type
   */
  token_type?: string;
};

/**
 * RepositoryAnalysis
 */
export type RepositoryAnalysis = {
  /**
   * Domain Type
   */
  domain_type?: string | null;
  /**
   * Complexity Score
   */
  complexity_score?: string | null;
  /**
   * Languages
   */
  languages?: string | null;
  /**
   * Frameworks
   */
  frameworks?: string | null;
  /**
   * Total Pages
   */
  total_pages?: string | null;
};

/**
 * RepositoryDocsData
 */
export type RepositoryDocsData = {
  repository: RepositoryInfo;
  analysis: RepositoryAnalysis;
  navigation: NavigationData;
  /**
   * Folder Structure
   */
  folder_structure: unknown;
  /**
   * Content
   */
  content: {
    [key: string]: DocumentationFile;
  };
};

/**
 * RepositoryDocsResponse
 */
export type RepositoryDocsResponse = {
  /**
   * Success
   */
  success: boolean;
  data: RepositoryDocsData;
  /**
   * Message
   */
  message: string;
};

/**
 * RepositoryInfo
 */
export type RepositoryInfo = {
  /**
   * Id
   */
  id: string;
  /**
   * Name
   */
  name: string;
  /**
   * Directory
   */
  directory: string;
};

/**
 * SidebarItem
 */
export type SidebarItem = {
  /**
   * Title
   */
  title: string;
  /**
   * Filename
   */
  filename: string;
  /**
   * Emoji
   */
  emoji: string;
  /**
   * Url
   */
  url: string;
};

/**
 * StructureResponse
 */
export type StructureResponse = {
  /**
   * Directory Tree
   */
  directory_tree: string;
  /**
   * Files
   */
  files: Array<FileData>;
};

/**
 * TaskStatus
 */
export type TaskStatus = {
  /**
   * Task Id
   */
  task_id: string;
  /**
   * Status
   */
  status: string;
  /**
   * Message
   */
  message: string;
  /**
   * Error
   */
  error?: string | null;
  /**
   * Created At
   */
  created_at: number;
  /**
   * Completed At
   */
  completed_at?: number | null;
};

/**
 * TextResponse
 */
export type TextResponse = {
  /**
   * Text Content
   */
  text_content: string;
  /**
   * Filename Suggestion
   */
  filename_suggestion: string;
  /**
   * Repo Id
   */
  repo_id: string;
};

/**
 * TokenUsage
 * Token usage information
 */
export type TokenUsage = {
  /**
   * Prompt Tokens
   */
  prompt_tokens?: number;
  /**
   * Completion Tokens
   */
  completion_tokens?: number;
  /**
   * Total Tokens
   */
  total_tokens?: number;
};

/**
 * ValidationError
 */
export type ValidationError = {
  /**
   * Location
   */
  loc: Array<string | number>;
  /**
   * Message
   */
  msg: string;
  /**
   * Error Type
   */
  type: string;
};

/**
 * WikiGenerationResponse
 */
export type WikiGenerationResponse = {
  /**
   * Status
   */
  status: string;
  /**
   * Message
   */
  message: string;
  /**
   * Task Id
   */
  task_id?: string | null;
  /**
   * Result
   */
  result?: {
    [key: string]: unknown;
  } | null;
};

export type GenerateTextRouteApiRepoGenerateTextPostData = {
  body?: BodyGenerateTextRouteApiRepoGenerateTextPost;
  headers?: {
    /**
     * Authorization
     */
    authorization?: string | null;
  };
  path?: never;
  query?: never;
  url: '/api/repo/generate-text';
};

export type GenerateTextRouteApiRepoGenerateTextPostErrors = {
  /**
   * Invalid input (e.g., no URL or ZIP provided).
   */
  400: ErrorResponse;
  /**
   * Invalid or expired JWT token.
   */
  401: ErrorResponse;
  /**
   * Could not download repository or no suitable files found.
   */
  404: ErrorResponse;
  /**
   * Validation Error
   */
  422: HttpValidationError;
  /**
   * Server error during processing.
   */
  500: ErrorResponse;
};

export type GenerateTextRouteApiRepoGenerateTextPostError =
  GenerateTextRouteApiRepoGenerateTextPostErrors[keyof GenerateTextRouteApiRepoGenerateTextPostErrors];

export type GenerateTextRouteApiRepoGenerateTextPostResponses = {
  /**
   * Repository content as JSON (cached or newly generated).
   */
  200: TextResponse;
};

export type GenerateTextRouteApiRepoGenerateTextPostResponse =
  GenerateTextRouteApiRepoGenerateTextPostResponses[keyof GenerateTextRouteApiRepoGenerateTextPostResponses];

export type GenerateGraphRouteApiRepoGenerateGraphPostData = {
  body?: BodyGenerateGraphRouteApiRepoGenerateGraphPost;
  headers?: {
    /**
     * Authorization
     */
    authorization?: string | null;
  };
  path?: never;
  query?: never;
  url: '/api/repo/generate-graph';
};

export type GenerateGraphRouteApiRepoGenerateGraphPostErrors = {
  /**
   * Invalid input (e.g., no URL or ZIP provided).
   */
  400: ErrorResponse;
  /**
   * Invalid or expired JWT token.
   */
  401: ErrorResponse;
  /**
   * Repository not found or no suitable files for graph generation.
   */
  404: ErrorResponse;
  /**
   * Validation Error
   */
  422: HttpValidationError;
  /**
   * Server error during graph generation.
   */
  500: ErrorResponse;
};

export type GenerateGraphRouteApiRepoGenerateGraphPostError =
  GenerateGraphRouteApiRepoGenerateGraphPostErrors[keyof GenerateGraphRouteApiRepoGenerateGraphPostErrors];

export type GenerateGraphRouteApiRepoGenerateGraphPostResponses = {
  /**
   * Dependency graph data as JSON (cached or newly generated).
   */
  200: GraphResponse;
};

export type GenerateGraphRouteApiRepoGenerateGraphPostResponse =
  GenerateGraphRouteApiRepoGenerateGraphPostResponses[keyof GenerateGraphRouteApiRepoGenerateGraphPostResponses];

export type GenerateSubgraphRouteApiRepoGenerateSubgraphPostData = {
  body?: BodyGenerateSubgraphRouteApiRepoGenerateSubgraphPost;
  headers?: {
    /**
     * Authorization
     */
    authorization?: string | null;
  };
  path?: never;
  query?: never;
  url: '/api/repo/generate-subgraph';
};

export type GenerateSubgraphRouteApiRepoGenerateSubgraphPostErrors = {
  /**
   * Invalid input.
   */
  400: ErrorResponse;
  /**
   * Invalid or expired JWT token.
   */
  401: ErrorResponse;
  /**
   * Repository not found or no graph available.
   */
  404: ErrorResponse;
  /**
   * Validation Error
   */
  422: HttpValidationError;
  /**
   * Server error during subgraph generation.
   */
  500: ErrorResponse;
};

export type GenerateSubgraphRouteApiRepoGenerateSubgraphPostError =
  GenerateSubgraphRouteApiRepoGenerateSubgraphPostErrors[keyof GenerateSubgraphRouteApiRepoGenerateSubgraphPostErrors];

export type GenerateSubgraphRouteApiRepoGenerateSubgraphPostResponses = {
  /**
   * Subgraph data as JSON.
   */
  200: GraphResponse;
};

export type GenerateSubgraphRouteApiRepoGenerateSubgraphPostResponse =
  GenerateSubgraphRouteApiRepoGenerateSubgraphPostResponses[keyof GenerateSubgraphRouteApiRepoGenerateSubgraphPostResponses];

export type GenerateStructureRouteApiRepoGenerateStructurePostData = {
  body?: BodyGenerateStructureRouteApiRepoGenerateStructurePost;
  headers?: {
    /**
     * Authorization
     */
    authorization?: string | null;
  };
  path?: never;
  query?: never;
  url: '/api/repo/generate-structure';
};

export type GenerateStructureRouteApiRepoGenerateStructurePostErrors = {
  /**
   * Invalid input (e.g., no URL or ZIP provided).
   */
  400: ErrorResponse;
  /**
   * Invalid or expired JWT token.
   */
  401: ErrorResponse;
  /**
   * Repository not found or no suitable files after filtering.
   */
  404: ErrorResponse;
  /**
   * Validation Error
   */
  422: HttpValidationError;
  /**
   * Server error during structure generation.
   */
  500: ErrorResponse;
};

export type GenerateStructureRouteApiRepoGenerateStructurePostError =
  GenerateStructureRouteApiRepoGenerateStructurePostErrors[keyof GenerateStructureRouteApiRepoGenerateStructurePostErrors];

export type GenerateStructureRouteApiRepoGenerateStructurePostResponses = {
  /**
   * Repository structure and content as JSON (cached or newly generated).
   */
  200: StructureResponse;
};

export type GenerateStructureRouteApiRepoGenerateStructurePostResponse =
  GenerateStructureRouteApiRepoGenerateStructurePostResponses[keyof GenerateStructureRouteApiRepoGenerateStructurePostResponses];

export type LoginUserApiBackendAuthLoginPostData = {
  body: LoginRequest;
  path?: never;
  query?: never;
  url: '/api/backend-auth/login';
};

export type LoginUserApiBackendAuthLoginPostErrors = {
  /**
   * Bad request. GitHub token is invalid or does not return required user data (email/username).
   */
  400: ErrorResponse;
  /**
   * Unauthorized. GitHub token is invalid or expired.
   */
  401: ErrorResponse;
  /**
   * Validation Error
   */
  422: HttpValidationError;
  /**
   * Internal server error.
   */
  500: ErrorResponse;
};

export type LoginUserApiBackendAuthLoginPostError =
  LoginUserApiBackendAuthLoginPostErrors[keyof LoginUserApiBackendAuthLoginPostErrors];

export type LoginUserApiBackendAuthLoginPostResponses = {
  /**
   * Login successful. Returns JWT and user ID.
   */
  200: LoginResponse;
};

export type LoginUserApiBackendAuthLoginPostResponse =
  LoginUserApiBackendAuthLoginPostResponses[keyof LoginUserApiBackendAuthLoginPostResponses];

export type RefreshTokenApiBackendAuthRefreshPostData = {
  body: RefreshTokenRequest;
  path?: never;
  query?: never;
  url: '/api/backend-auth/refresh';
};

export type RefreshTokenApiBackendAuthRefreshPostErrors = {
  /**
   * Unauthorized. Refresh token is invalid or expired.
   */
  401: ErrorResponse;
  /**
   * User not found.
   */
  404: ErrorResponse;
  /**
   * Validation Error
   */
  422: HttpValidationError;
  /**
   * Internal server error.
   */
  500: ErrorResponse;
};

export type RefreshTokenApiBackendAuthRefreshPostError =
  RefreshTokenApiBackendAuthRefreshPostErrors[keyof RefreshTokenApiBackendAuthRefreshPostErrors];

export type RefreshTokenApiBackendAuthRefreshPostResponses = {
  /**
   * Token refresh successful. Returns new access token.
   */
  200: RefreshTokenResponse;
};

export type RefreshTokenApiBackendAuthRefreshPostResponse =
  RefreshTokenApiBackendAuthRefreshPostResponses[keyof RefreshTokenApiBackendAuthRefreshPostResponses];

export type ProcessChatMessageApiBackendChatChatPostData = {
  body: BodyProcessChatMessageApiBackendChatChatPost;
  headers?: {
    /**
     * Authorization
     */
    authorization?: string | null;
  };
  path?: never;
  query?: never;
  url: '/api/backend-chat/chat';
};

export type ProcessChatMessageApiBackendChatChatPostErrors = {
  /**
   * Unauthorized - Invalid JWT token
   */
  401: ErrorResponse;
  /**
   * Repository or chat session not found
   */
  404: ErrorResponse;
  /**
   * Validation Error
   */
  422: HttpValidationError;
  /**
   * Rate limit exceeded
   */
  429: ErrorResponse;
  /**
   * Internal server error
   */
  500: ErrorResponse;
};

export type ProcessChatMessageApiBackendChatChatPostError =
  ProcessChatMessageApiBackendChatChatPostErrors[keyof ProcessChatMessageApiBackendChatChatPostErrors];

export type ProcessChatMessageApiBackendChatChatPostResponses = {
  /**
   * Successful response with AI-generated content
   */
  200: ChatResponse;
};

export type ProcessChatMessageApiBackendChatChatPostResponse =
  ProcessChatMessageApiBackendChatChatPostResponses[keyof ProcessChatMessageApiBackendChatChatPostResponses];

export type StreamChatResponseApiBackendChatChatStreamPostData = {
  body: BodyStreamChatResponseApiBackendChatChatStreamPost;
  headers?: {
    /**
     * Authorization
     */
    authorization?: string | null;
  };
  path?: never;
  query?: never;
  url: '/api/backend-chat/chat/stream';
};

export type StreamChatResponseApiBackendChatChatStreamPostErrors = {
  /**
   * Unauthorized - Invalid JWT token
   */
  401: ErrorResponse;
  /**
   * Repository or chat session not found
   */
  404: ErrorResponse;
  /**
   * Validation Error
   */
  422: HttpValidationError;
  /**
   * Rate limit exceeded
   */
  429: ErrorResponse;
  /**
   * Internal server error
   */
  500: ErrorResponse;
};

export type StreamChatResponseApiBackendChatChatStreamPostError =
  StreamChatResponseApiBackendChatChatStreamPostErrors[keyof StreamChatResponseApiBackendChatChatStreamPostErrors];

export type StreamChatResponseApiBackendChatChatStreamPostResponses = {
  /**
   * Successful streaming response
   */
  200: unknown;
};

export type GetConversationHistoryApiBackendChatConversationsConversationIdPostData = {
  body?: never;
  headers?: {
    /**
     * Authorization
     */
    authorization?: string | null;
  };
  path: {
    /**
     * Conversation Id
     */
    conversation_id: string;
  };
  query?: never;
  url: '/api/backend-chat/conversations/{conversation_id}';
};

export type GetConversationHistoryApiBackendChatConversationsConversationIdPostErrors = {
  /**
   * Unauthorized - Invalid JWT token
   */
  401: ErrorResponse;
  /**
   * Conversation not found
   */
  404: ErrorResponse;
  /**
   * Validation Error
   */
  422: HttpValidationError;
  /**
   * Internal server error
   */
  500: ErrorResponse;
};

export type GetConversationHistoryApiBackendChatConversationsConversationIdPostError =
  GetConversationHistoryApiBackendChatConversationsConversationIdPostErrors[keyof GetConversationHistoryApiBackendChatConversationsConversationIdPostErrors];

export type GetConversationHistoryApiBackendChatConversationsConversationIdPostResponses = {
  /**
   * Successful retrieval of conversation history
   */
  200: ConversationHistoryResponse;
};

export type GetConversationHistoryApiBackendChatConversationsConversationIdPostResponse =
  GetConversationHistoryApiBackendChatConversationsConversationIdPostResponses[keyof GetConversationHistoryApiBackendChatConversationsConversationIdPostResponses];

export type ListUserChatSessionsApiBackendChatSessionsPostData = {
  body: BodyListUserChatSessionsApiBackendChatSessionsPost;
  headers?: {
    /**
     * Authorization
     */
    authorization?: string | null;
  };
  path?: never;
  query?: never;
  url: '/api/backend-chat/sessions';
};

export type ListUserChatSessionsApiBackendChatSessionsPostErrors = {
  /**
   * Unauthorized - Invalid JWT token
   */
  401: ErrorResponse;
  /**
   * Validation Error
   */
  422: HttpValidationError;
  /**
   * Internal server error
   */
  500: ErrorResponse;
};

export type ListUserChatSessionsApiBackendChatSessionsPostError =
  ListUserChatSessionsApiBackendChatSessionsPostErrors[keyof ListUserChatSessionsApiBackendChatSessionsPostErrors];

export type ListUserChatSessionsApiBackendChatSessionsPostResponses = {
  /**
   * Successful retrieval of chat sessions
   */
  200: ChatSessionListResponse;
};

export type ListUserChatSessionsApiBackendChatSessionsPostResponse =
  ListUserChatSessionsApiBackendChatSessionsPostResponses[keyof ListUserChatSessionsApiBackendChatSessionsPostResponses];

export type GetChatSessionApiBackendChatSessionsChatIdPostData = {
  body?: never;
  headers?: {
    /**
     * Authorization
     */
    authorization?: string | null;
  };
  path: {
    /**
     * Chat Id
     */
    chat_id: string;
  };
  query?: never;
  url: '/api/backend-chat/sessions/{chat_id}';
};

export type GetChatSessionApiBackendChatSessionsChatIdPostErrors = {
  /**
   * Unauthorized - Invalid JWT token
   */
  401: ErrorResponse;
  /**
   * Chat session not found
   */
  404: ErrorResponse;
  /**
   * Validation Error
   */
  422: HttpValidationError;
  /**
   * Internal server error
   */
  500: ErrorResponse;
};

export type GetChatSessionApiBackendChatSessionsChatIdPostError =
  GetChatSessionApiBackendChatSessionsChatIdPostErrors[keyof GetChatSessionApiBackendChatSessionsChatIdPostErrors];

export type GetChatSessionApiBackendChatSessionsChatIdPostResponses = {
  /**
   * Successful retrieval of chat session
   */
  200: ChatSessionResponse;
};

export type GetChatSessionApiBackendChatSessionsChatIdPostResponse =
  GetChatSessionApiBackendChatSessionsChatIdPostResponses[keyof GetChatSessionApiBackendChatSessionsChatIdPostResponses];

export type VerifyApiKeyBackendEnhancedData = {
  body: BodyVerifyApiKeyBackendEnhanced;
  path?: never;
  query?: never;
  url: '/api/backend-chat/keys/verify';
};

export type VerifyApiKeyBackendEnhancedErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type VerifyApiKeyBackendEnhancedError =
  VerifyApiKeyBackendEnhancedErrors[keyof VerifyApiKeyBackendEnhancedErrors];

export type VerifyApiKeyBackendEnhancedResponses = {
  /**
   * Successful Response
   */
  200: unknown;
};

export type SaveApiKeyBackendEnhancedData = {
  body: BodySaveApiKeyBackendEnhanced;
  path?: never;
  query?: never;
  url: '/api/backend-chat/keys/save';
};

export type SaveApiKeyBackendEnhancedErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type SaveApiKeyBackendEnhancedError =
  SaveApiKeyBackendEnhancedErrors[keyof SaveApiKeyBackendEnhancedErrors];

export type SaveApiKeyBackendEnhancedResponses = {
  /**
   * Successful Response
   */
  200: unknown;
};

export type GetAvailableModelsApiBackendChatModelsPostData = {
  body?: never;
  headers?: {
    /**
     * Authorization
     */
    authorization?: string | null;
  };
  path?: never;
  query?: never;
  url: '/api/backend-chat/models';
};

export type GetAvailableModelsApiBackendChatModelsPostErrors = {
  /**
   * Unauthorized - Invalid JWT token
   */
  401: ErrorResponse;
  /**
   * Validation Error
   */
  422: HttpValidationError;
  /**
   * Internal server error
   */
  500: ErrorResponse;
};

export type GetAvailableModelsApiBackendChatModelsPostError =
  GetAvailableModelsApiBackendChatModelsPostErrors[keyof GetAvailableModelsApiBackendChatModelsPostErrors];

export type GetAvailableModelsApiBackendChatModelsPostResponses = {
  /**
   * Successful retrieval of available models
   */
  200: AvailableModelsResponse;
};

export type GetAvailableModelsApiBackendChatModelsPostResponse =
  GetAvailableModelsApiBackendChatModelsPostResponses[keyof GetAvailableModelsApiBackendChatModelsPostResponses];

export type UpdateChatSettingsApiBackendChatSettingsPostData = {
  body: BodyUpdateChatSettingsApiBackendChatSettingsPost;
  headers?: {
    /**
     * Authorization
     */
    authorization?: string | null;
  };
  path?: never;
  query?: never;
  url: '/api/backend-chat/settings';
};

export type UpdateChatSettingsApiBackendChatSettingsPostErrors = {
  /**
   * Unauthorized - Invalid JWT token
   */
  401: ErrorResponse;
  /**
   * Chat session not found
   */
  404: ErrorResponse;
  /**
   * Validation Error
   */
  422: HttpValidationError;
  /**
   * Internal server error
   */
  500: ErrorResponse;
};

export type UpdateChatSettingsApiBackendChatSettingsPostError =
  UpdateChatSettingsApiBackendChatSettingsPostErrors[keyof UpdateChatSettingsApiBackendChatSettingsPostErrors];

export type UpdateChatSettingsApiBackendChatSettingsPostResponses = {
  /**
   * Settings updated successfully
   */
  200: ChatSettingsResponse;
};

export type UpdateChatSettingsApiBackendChatSettingsPostResponse =
  UpdateChatSettingsApiBackendChatSettingsPostResponses[keyof UpdateChatSettingsApiBackendChatSettingsPostResponses];

export type SearchContextApiBackendChatContextSearchPostData = {
  body: BodySearchContextApiBackendChatContextSearchPost;
  headers?: {
    /**
     * Authorization
     */
    authorization?: string | null;
  };
  path?: never;
  query?: never;
  url: '/api/backend-chat/context/search';
};

export type SearchContextApiBackendChatContextSearchPostErrors = {
  /**
   * Unauthorized - Invalid JWT token
   */
  401: ErrorResponse;
  /**
   * Repository not found
   */
  404: ErrorResponse;
  /**
   * Validation Error
   */
  422: HttpValidationError;
  /**
   * Internal server error
   */
  500: ErrorResponse;
};

export type SearchContextApiBackendChatContextSearchPostError =
  SearchContextApiBackendChatContextSearchPostErrors[keyof SearchContextApiBackendChatContextSearchPostErrors];

export type SearchContextApiBackendChatContextSearchPostResponses = {
  /**
   * Successful context search
   */
  200: ContextSearchResponse;
};

export type SearchContextApiBackendChatContextSearchPostResponse =
  SearchContextApiBackendChatContextSearchPostResponses[keyof SearchContextApiBackendChatContextSearchPostResponses];

export type StreamWikiProgressApiDocumentationProgressStreamTaskIdGetData = {
  body?: never;
  path: {
    /**
     * Task Id
     */
    task_id: string;
  };
  query?: never;
  url: '/api/documentation/progress-stream/{task_id}';
};

export type StreamWikiProgressApiDocumentationProgressStreamTaskIdGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type StreamWikiProgressApiDocumentationProgressStreamTaskIdGetError =
  StreamWikiProgressApiDocumentationProgressStreamTaskIdGetErrors[keyof StreamWikiProgressApiDocumentationProgressStreamTaskIdGetErrors];

export type StreamWikiProgressApiDocumentationProgressStreamTaskIdGetResponses = {
  /**
   * Successful Response
   */
  200: unknown;
};

export type CancelWikiGenerationApiDocumentationCancelGenerationTaskIdPostData = {
  body?: never;
  headers?: {
    /**
     * Authorization
     */
    authorization?: string | null;
  };
  path: {
    /**
     * Task Id
     */
    task_id: string;
  };
  query?: never;
  url: '/api/documentation/cancel-generation/{task_id}';
};

export type CancelWikiGenerationApiDocumentationCancelGenerationTaskIdPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type CancelWikiGenerationApiDocumentationCancelGenerationTaskIdPostError =
  CancelWikiGenerationApiDocumentationCancelGenerationTaskIdPostErrors[keyof CancelWikiGenerationApiDocumentationCancelGenerationTaskIdPostErrors];

export type CancelWikiGenerationApiDocumentationCancelGenerationTaskIdPostResponses = {
  /**
   * Successful Response
   */
  200: unknown;
};

export type GenerateWikiApiDocumentationGenerateWikiPostData = {
  body: BodyGenerateWikiApiDocumentationGenerateWikiPost;
  headers?: {
    /**
     * Authorization
     */
    authorization?: string | null;
  };
  path?: never;
  query?: never;
  url: '/api/documentation/generate-wiki';
};

export type GenerateWikiApiDocumentationGenerateWikiPostErrors = {
  /**
   * Bad request. Invalid input parameters.
   */
  400: unknown;
  /**
   * Validation Error
   */
  422: HttpValidationError;
  /**
   * Internal server error.
   */
  500: unknown;
};

export type GenerateWikiApiDocumentationGenerateWikiPostError =
  GenerateWikiApiDocumentationGenerateWikiPostErrors[keyof GenerateWikiApiDocumentationGenerateWikiPostErrors];

export type GenerateWikiApiDocumentationGenerateWikiPostResponses = {
  /**
   * Task ID and status of the wiki generation process.
   */
  200: WikiGenerationResponse;
  /**
   * Wiki generation task accepted and started.
   */
  202: WikiGenerationResponse;
};

export type GenerateWikiApiDocumentationGenerateWikiPostResponse =
  GenerateWikiApiDocumentationGenerateWikiPostResponses[keyof GenerateWikiApiDocumentationGenerateWikiPostResponses];

export type GetWikiStatusApiDocumentationWikiStatusPostData = {
  body: BodyGetWikiStatusApiDocumentationWikiStatusPost;
  headers?: {
    /**
     * Authorization
     */
    authorization?: string | null;
  };
  path?: never;
  query?: never;
  url: '/api/documentation/wiki-status';
};

export type GetWikiStatusApiDocumentationWikiStatusPostErrors = {
  /**
   * Task ID not found.
   */
  404: unknown;
  /**
   * Validation Error
   */
  422: HttpValidationError;
  /**
   * Internal server error.
   */
  500: unknown;
};

export type GetWikiStatusApiDocumentationWikiStatusPostError =
  GetWikiStatusApiDocumentationWikiStatusPostErrors[keyof GetWikiStatusApiDocumentationWikiStatusPostErrors];

export type GetWikiStatusApiDocumentationWikiStatusPostResponses = {
  /**
   * Task status retrieved successfully.
   */
  200: TaskStatus;
};

export type GetWikiStatusApiDocumentationWikiStatusPostResponse =
  GetWikiStatusApiDocumentationWikiStatusPostResponses[keyof GetWikiStatusApiDocumentationWikiStatusPostResponses];

export type IsWikiGeneratedApiDocumentationIsWikiGeneratedPostData = {
  body: BodyIsWikiGeneratedApiDocumentationIsWikiGeneratedPost;
  headers?: {
    /**
     * Authorization
     */
    authorization?: string | null;
  };
  path?: never;
  query?: never;
  url: '/api/documentation/is-wiki-generated';
};

export type IsWikiGeneratedApiDocumentationIsWikiGeneratedPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type IsWikiGeneratedApiDocumentationIsWikiGeneratedPostError =
  IsWikiGeneratedApiDocumentationIsWikiGeneratedPostErrors[keyof IsWikiGeneratedApiDocumentationIsWikiGeneratedPostErrors];

export type IsWikiGeneratedApiDocumentationIsWikiGeneratedPostResponses = {
  /**
   * Boolean indicating if wiki documentation is generated.
   */
  200: IsWikiGeneratedResponse;
};

export type IsWikiGeneratedApiDocumentationIsWikiGeneratedPostResponse =
  IsWikiGeneratedApiDocumentationIsWikiGeneratedPostResponses[keyof IsWikiGeneratedApiDocumentationIsWikiGeneratedPostResponses];

export type ListRepositoryDocsApiDocumentationRepositoryDocsPostData = {
  body: BodyListRepositoryDocsApiDocumentationRepositoryDocsPost;
  headers?: {
    /**
     * Authorization
     */
    authorization?: string | null;
  };
  path?: never;
  query?: never;
  url: '/api/documentation/repository-docs';
};

export type ListRepositoryDocsApiDocumentationRepositoryDocsPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListRepositoryDocsApiDocumentationRepositoryDocsPostError =
  ListRepositoryDocsApiDocumentationRepositoryDocsPostErrors[keyof ListRepositoryDocsApiDocumentationRepositoryDocsPostErrors];

export type ListRepositoryDocsApiDocumentationRepositoryDocsPostResponses = {
  /**
   * Structured documentation data for the repository.
   */
  200: RepositoryDocsResponse;
};

export type ListRepositoryDocsApiDocumentationRepositoryDocsPostResponse =
  ListRepositoryDocsApiDocumentationRepositoryDocsPostResponses[keyof ListRepositoryDocsApiDocumentationRepositoryDocsPostResponses];

export type GetIndexedRepositoriesApiIndexedReposPostData = {
  body?: BodyGetIndexedRepositoriesApiIndexedReposPost;
  headers?: {
    /**
     * Authorization
     */
    authorization?: string | null;
  };
  path?: never;
  query?: never;
  url: '/api/indexed-repos/';
};

export type GetIndexedRepositoriesApiIndexedReposPostErrors = {
  /**
   * Authentication required - missing or invalid JWT token
   */
  401: ErrorResponse;
  /**
   * Validation Error
   */
  422: HttpValidationError;
  /**
   * Server error while fetching repositories
   */
  500: ErrorResponse;
};

export type GetIndexedRepositoriesApiIndexedReposPostError =
  GetIndexedRepositoriesApiIndexedReposPostErrors[keyof GetIndexedRepositoriesApiIndexedReposPostErrors];

export type GetIndexedRepositoriesApiIndexedReposPostResponses = {
  /**
   * Successfully retrieved indexed repositories
   */
  200: IndexedRepositoriesResponse;
};

export type GetIndexedRepositoriesApiIndexedReposPostResponse =
  GetIndexedRepositoriesApiIndexedReposPostResponses[keyof GetIndexedRepositoriesApiIndexedReposPostResponses];

export type GetUserApiKeysBackendEnhancedData = {
  body: BodyGetUserApiKeysBackendEnhanced;
  path?: never;
  query?: never;
  url: '/api/backend-chat/keys/list';
};

export type GetUserApiKeysBackendEnhancedErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetUserApiKeysBackendEnhancedError =
  GetUserApiKeysBackendEnhancedErrors[keyof GetUserApiKeysBackendEnhancedErrors];

export type GetUserApiKeysBackendEnhancedResponses = {
  /**
   * Successful Response
   */
  200: unknown;
};

export type DeleteUserApiKeyBackendEnhancedData = {
  body: BodyDeleteUserApiKeyBackendEnhanced;
  path?: never;
  query?: never;
  url: '/api/backend-chat/keys/delete';
};

export type DeleteUserApiKeyBackendEnhancedErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type DeleteUserApiKeyBackendEnhancedError =
  DeleteUserApiKeyBackendEnhancedErrors[keyof DeleteUserApiKeyBackendEnhancedErrors];

export type DeleteUserApiKeyBackendEnhancedResponses = {
  /**
   * Successful Response
   */
  200: unknown;
};

export type GetAvailableModelsGetBackendEnhancedData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Token
     */
    token?: string | null;
    /**
     * Provider
     */
    provider?: string | null;
  };
  url: '/api/backend-chat/models/available';
};

export type GetAvailableModelsGetBackendEnhancedErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetAvailableModelsGetBackendEnhancedError =
  GetAvailableModelsGetBackendEnhancedErrors[keyof GetAvailableModelsGetBackendEnhancedErrors];

export type GetAvailableModelsGetBackendEnhancedResponses = {
  /**
   * Successful Response
   */
  200: unknown;
};

export type GetAvailableModelsBackendEnhancedData = {
  body?: BodyGetAvailableModelsBackendEnhanced;
  headers?: {
    /**
     * Authorization
     */
    authorization?: string | null;
  };
  path?: never;
  query?: never;
  url: '/api/backend-chat/models/available';
};

export type GetAvailableModelsBackendEnhancedErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetAvailableModelsBackendEnhancedError =
  GetAvailableModelsBackendEnhancedErrors[keyof GetAvailableModelsBackendEnhancedErrors];

export type GetAvailableModelsBackendEnhancedResponses = {
  /**
   * Successful Response
   */
  200: unknown;
};

export type GetModelConfigBackendEnhancedData = {
  body?: never;
  path: {
    /**
     * Provider
     */
    provider: string;
    /**
     * Model
     */
    model: string;
  };
  query?: never;
  url: '/api/backend-chat/models/{provider}/{model}/config';
};

export type GetModelConfigBackendEnhancedErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetModelConfigBackendEnhancedError =
  GetModelConfigBackendEnhancedErrors[keyof GetModelConfigBackendEnhancedErrors];

export type GetModelConfigBackendEnhancedResponses = {
  /**
   * Successful Response
   */
  200: unknown;
};

export type HealthCheckBackendEnhancedData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/backend-chat/health';
};

export type HealthCheckBackendEnhancedResponses = {
  /**
   * Successful Response
   */
  200: unknown;
};

export type ServiceInfoBackendEnhancedData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/backend-chat/info';
};

export type ServiceInfoBackendEnhancedResponses = {
  /**
   * Successful Response
   */
  200: unknown;
};

export type GetGithubInstallationsApiGithubInstallationsPostData = {
  body?: never;
  headers?: {
    /**
     * Authorization
     */
    authorization?: string | null;
  };
  path?: never;
  query?: never;
  url: '/api/github/installations';
};

export type GetGithubInstallationsApiGithubInstallationsPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetGithubInstallationsApiGithubInstallationsPostError =
  GetGithubInstallationsApiGithubInstallationsPostErrors[keyof GetGithubInstallationsApiGithubInstallationsPostErrors];

export type GetGithubInstallationsApiGithubInstallationsPostResponses = {
  /**
   * Successful Response
   */
  200: GitHubInstallationsResponse;
};

export type GetGithubInstallationsApiGithubInstallationsPostResponse =
  GetGithubInstallationsApiGithubInstallationsPostResponses[keyof GetGithubInstallationsApiGithubInstallationsPostResponses];

export type GetGithubInstallationRepositoriesApiGithubInstallationsInstallationIdRepositoriesPostData =
  {
    body?: never;
    headers?: {
      /**
       * Authorization
       */
      authorization?: string | null;
    };
    path: {
      /**
       * Installation Id
       */
      installation_id: number;
    };
    query?: never;
    url: '/api/github/installations/{installation_id}/repositories';
  };

export type GetGithubInstallationRepositoriesApiGithubInstallationsInstallationIdRepositoriesPostErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GetGithubInstallationRepositoriesApiGithubInstallationsInstallationIdRepositoriesPostError =
  GetGithubInstallationRepositoriesApiGithubInstallationsInstallationIdRepositoriesPostErrors[keyof GetGithubInstallationRepositoriesApiGithubInstallationsInstallationIdRepositoriesPostErrors];

export type GetGithubInstallationRepositoriesApiGithubInstallationsInstallationIdRepositoriesPostResponses =
  {
    /**
     * Successful Response
     */
    200: GitHubRepositoriesResponse;
  };

export type GetGithubInstallationRepositoriesApiGithubInstallationsInstallationIdRepositoriesPostResponse =
  GetGithubInstallationRepositoriesApiGithubInstallationsInstallationIdRepositoriesPostResponses[keyof GetGithubInstallationRepositoriesApiGithubInstallationsInstallationIdRepositoriesPostResponses];

export type ClientOptions = {
  baseUrl: 'http://localhost:8003' | (string & {});
};
